<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anika Blue</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --default-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --page-background: var(--default-gradient);
            --page-foreground: #fdfdfd;
            --shade-color: rgba(218, 222, 233, 0.92);
        }

        html {
            min-height: 100%;
            background: var(--page-background);
            background-attachment: fixed;
            background-repeat: no-repeat;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--page-background);
            background-attachment: fixed;
            background-repeat: no-repeat;
            color: var(--page-foreground);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 16px calc(48px + env(safe-area-inset-bottom, 0px));
            gap: 24px;
        }

        .container {
            width: min(100%, 560px);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 12px;
            color: var(--page-foreground);
        }

        .header h1 {
            font-size: clamp(2.1rem, 5vw, 2.4rem);
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: clamp(0.95rem, 2.8vw, 1.05rem);
            opacity: 0.88;
        }

        .card-container {
            background: rgba(218, 222, 233, 0.92);
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            min-height: clamp(360px, 65vh, 620px);
            display: flex;
            flex-direction: column;
            color: #1f2933;
        }

        .shade-display {
            width: 100%;
            flex: 1;
            min-height: clamp(260px, 55vh, 360px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: background-color 0.8s ease;
            position: relative;
            overflow: hidden;
        }

        .shade-display::before {
            content: "";
            position: absolute;
            inset: -20%;
            background: var(--shade-color);
            filter: blur(36px);
            opacity: 0.8;
            transform: scale(1.1);
        }

        .shade-display::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.18) 0%, rgba(255,255,255,0.08) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.25);
        }

        .shade-display > * {
            position: relative;
            z-index: 1;
        }

        .hex-code {
            background: rgba(255,255,255,0.9);
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 2rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            margin-top: 20px;
            transition: opacity 0.3s ease;
        }

        .hex-code.copyable {
            cursor: pointer;
            transition: opacity 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            outline: none;
        }

        .hex-code.copyable:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 18px rgba(0,0,0,0.25);
        }

        .hex-code.copyable:active {
            transform: scale(0.98);
        }

        .hex-code.copyable:focus-visible {
            transform: scale(1.02);
            box-shadow: 0 8px 18px rgba(0,0,0,0.25);
        }

        .controls {
            padding: 28px 30px;
            display: flex;
            justify-content: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.22);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            transition: background 0.8s ease, color 0.8s ease;
        }

        button {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        button:active {
            transform: translateY(0);
            animation: button-pulse 0.3s ease;
        }

        @keyframes button-pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(0.95);
            }
            100% {
                transform: scale(1);
            }
        }

        @keyframes button-success {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        .animate-success {
            animation: button-success 0.4s ease;
        }

        .btn-yes {
            background: linear-gradient(135deg, #34d399 0%, #059669 100%);
            color: white;
        }

        .btn-no {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-skip {
            background: #e0e0e0;
            color: #666;
        }

        .stats-container {
            margin-top: 20px;
            background: rgba(199, 205, 220, 0.9);
            border-radius: 15px;
            padding: 20px;
        }

        .scroll-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--page-foreground);
            font-size: 1.35rem;
            line-height: 1;
            align-self: center;
            animation: indicator-bounce 2s infinite;
            margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 6px);
        }

        @keyframes indicator-bounce {
            0%, 100% {
                transform: translateY(0);
                opacity: 0.8;
            }
            50% {
                transform: translateY(6px);
                opacity: 1;
            }
        }

        .stat-item {
            margin-bottom: 20px;
        }

        .stat-item:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 16px;
        }

        .restore-pill {
            background: linear-gradient(135deg, #43cea2 0%, #185a9d 100%);
            color: white;
            border: none;
            border-radius: 999px;
            padding: 4px 14px;
            font-size: 0.78rem;
            font-weight: 600;
            cursor: pointer;
            letter-spacing: 0.4px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            white-space: nowrap;
        }

        .restore-pill:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
        }

        .restore-pill:active {
            transform: translateY(0);
        }

        .stat-color {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .stat-empty {
            text-align: center;
            color: #2b3148;
            padding: 24px 16px;
            background: rgba(255, 255, 255, 0.35);
            border-radius: 12px;
        }

        .color-swatch {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .color-swatch.copyable {
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            outline: none;
        }

        .color-swatch.copyable:hover {
            transform: scale(1.03);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .color-swatch.copyable:active {
            transform: scale(0.97);
        }

        .color-swatch.copyable:focus-visible {
            transform: scale(1.03);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            outline: 3px solid rgba(102, 126, 234, 0.35);
            outline-offset: 3px;
        }

        .color-info {
            flex: 1;
            color: #1f2933;
        }

        .color-hex {
            font-size: 1.3rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            margin-bottom: 4px;
            color: #1f2933;
        }

        .color-count {
            font-size: 0.9rem;
            color: #2b3148;
        }

        .loading {
            text-align: center;
            padding: 30px;
            color: #999;
        }

        .htmx-swapping {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .htmx-settling {
            opacity: 1;
        }

        @media (max-width: 600px) {
            .stat-color {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }

            .color-info {
                text-align: center;
            }

            .restore-pill {
                font-size: 0.72rem;
                padding: 4px 12px;
            }
        }

        .modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1100;
        }

        .modal.visible {
            display: flex;
        }

        .modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }

        .modal-content {
            position: relative;
            background: white;
            border-radius: 16px;
            padding: 30px;
            width: min(90vw, 360px);
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1;
        }

        .modal-content h2 {
            font-size: 1.4rem;
            color: #334;
            text-align: center;
        }

        .modal-input-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .modal-input-wrapper {
            position: relative;
            flex: 1;
        }

        .modal-input {
            width: 100%;
            padding: 12px 44px 12px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Courier New', monospace;
            transition: border-color 0.3s ease;
            text-align: center;
        }

        .modal-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .modal-input.invalid {
            border-color: #dc3545;
        }

        .modal-input.invalid:focus {
            border-color: #c82333;
        }

        .modal-copy-btn {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            border: none;
            background: transparent;
            font-size: 1.1rem;
            cursor: pointer;
            color: #667eea;
            padding: 4px;
            border-radius: 6px;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .modal-copy-btn:hover:enabled {
            background: rgba(102, 126, 234, 0.12);
            color: #4c51bf;
            transform: translateY(-50%);
        }

        .modal-copy-btn:disabled {
            cursor: not-allowed;
            color: #bbb;
            transform: translateY(-50%);
        }

        .modal-copy-btn:focus {
            outline: none;
            transform: translateY(-50%);
        }

        .modal-copy-btn.copy-feedback {
            background: rgba(102, 126, 234, 0.18);
            color: #4c51bf;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
        }

        .modal-color-preview {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            background: linear-gradient(45deg, #f5f5f5 25%, transparent 25%, transparent 50%, #f5f5f5 50%, #f5f5f5 75%, transparent 75%, transparent 100%);
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        .modal-message {
            min-height: 18px;
            text-align: center;
            font-size: 0.85rem;
        }

        .modal-message.error {
            color: #dc3545;
        }

        .modal-message.success {
            color: #28a745;
        }

        .modal-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 1.4rem;
            cursor: pointer;
            color: #999;
            padding: 4px;
        }

        .modal-close:hover {
            color: #333;
        }

        .modal-primary-btn {
            flex: 1;
            padding: 12px;
            background: linear-gradient(135deg, #43cea2 0%, #185a9d 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 500;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 2000;
            animation: slideIn 0.3s ease, slideOut 0.3s ease 4.7s;
            max-width: 350px;
        }

        .toast.success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }

        .toast.error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }

        .toast-color-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 52px;
            padding: 2px 8px;
            margin: 0 6px;
            border-radius: 999px;
            font-weight: 700;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.08);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Footer styles */
        .footer {
            margin-top: 30px;
            text-align: center;
            color: var(--page-foreground);
            opacity: 0.8;
            padding: 20px 0;
        }

        .footer a {
            color: var(--page-foreground);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: opacity 0.3s ease;
        }

        .footer a:hover {
            opacity: 1;
        }

        .github-logo {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        /* Card animations - keeping for potential future use */
        @keyframes swipeLeft {
            from {
                transform: translateX(0) rotate(0deg);
                opacity: 1;
            }
            to {
                transform: translateX(-150%) rotate(-30deg);
                opacity: 0;
            }
        }

        @keyframes swipeRight {
            from {
                transform: translateX(0) rotate(0deg);
                opacity: 1;
            }
            to {
                transform: translateX(150%) rotate(30deg);
                opacity: 0;
            }
        }

        @keyframes slideInNew {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .swipe-left {
            animation: swipeLeft 0.4s ease-out;
        }

        .swipe-right {
            animation: swipeRight 0.4s ease-out;
        }

        .slide-in-new {
            animation: slideInNew 0.4s ease-out;
        }

        #shade-container {
            position: relative;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 100%;
        }

        #shade-container > .shade-display {
            flex: 1;
        }

        #shade-container > .controls {
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>💙 Anika Blue 💙</h1>
            <p>Find your perfect shade of blue</p>
        </div>

        <div class="card-container" id="card-container">
            <div id="shade-container">
                <div class="loading">Loading...</div>
            </div>
        </div>

        <div class="scroll-indicator" role="presentation" aria-hidden="true">↓</div>

        <div id="stats-container">
        </div>

        <div class="footer">
            <a href="https://github.com/pschmitt/anika-blue" target="_blank" rel="noopener noreferrer">
                <svg class="github-logo" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                </svg>
                <span>View on GitHub</span>
            </a>
        </div>
    </div>

    <div id="restore-modal" class="modal">
        <div class="modal-backdrop" onclick="closeRestoreModal()"></div>
        <div class="modal-content">
            <button class="modal-close" onclick="closeRestoreModal()" aria-label="Close restore dialog">×</button>
            <h2>Restore Your Session</h2>
            <div class="modal-input-row">
                <div class="modal-input-wrapper">
                    <input type="text" id="base-color-input" class="modal-input" placeholder="#1a2b3c" maxlength="7">
                    <button id="restore-copy-btn" class="modal-copy-btn" type="button" onclick="copyRestoreColor(event)" aria-label="Copy color to clipboard">📋</button>
                </div>
                <div id="restore-color-preview" class="modal-color-preview" aria-hidden="true"></div>
            </div>
            <div id="restore-inline-message" class="modal-message"></div>
            <div class="modal-actions">
                <button class="modal-primary-btn" onclick="loadBaseColor(event)">🔄 Restore</button>
            </div>
        </div>
    </div>

    <script>
        const DEBUG_MODE = {{ debug | tojson }};
        const LIVE_RELOAD_POLL_MS = {{ livereload_interval | tojson }};
        let liveReloadToken = {{ livereload_token | tojson }};

        let currentShade = null;
        let currentUserBaseColor = null;
        let currentGlobalBaseColor = null;
        const HEX_COLOR_REGEX = /^#[0-9a-f]{6}$/i;

        function startLiveReload() {
            if (!DEBUG_MODE || !LIVE_RELOAD_POLL_MS) {
                return;
            }

            const pollInterval = Math.max(750, LIVE_RELOAD_POLL_MS);
            const endpoint = '/__livereload';
            let stopped = false;
            let intervalId;

            async function poll() {
                if (stopped) {
                    return;
                }

                try {
                    const response = await fetch(endpoint, { cache: 'no-store' });

                    if (!response.ok) {
                        if (response.status === 404) {
                            stopped = true;
                            if (intervalId) {
                                clearInterval(intervalId);
                            }
                        }
                        return;
                    }

                    const data = await response.json();
                    if (!data?.version) {
                        return;
                    }

                    if (liveReloadToken && data.version === liveReloadToken) {
                        return;
                    }

                    liveReloadToken = data.version;
                    window.location.reload();
                } catch (error) {
                    console.debug('Live reload poll failed', error);
                }
            }

            poll();
            intervalId = setInterval(poll, pollInterval);
        }

        async function loadNextShade() {
            try {
                const response = await fetch('/next-shade');
                const html = await response.text();
                
                // Extract the shade from the response
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;
                const shadeElement = tempDiv.querySelector('.shade-display');
                const newShade = shadeElement ? shadeElement.getAttribute('data-shade') || shadeElement.dataset.shade || null : null;
                const hexElement = tempDiv.querySelector('.hex-code');
                const newHex = hexElement ? hexElement.textContent : null;
                
                if (!newShade || !newHex) {
                    console.error('Could not extract shade from response');
                    return;
                }
                
                // Get existing elements
                const shadeContainer = document.getElementById('shade-container');
                let existingShadeDisplay = shadeContainer.querySelector('.shade-display');
                let existingHexCode = shadeContainer.querySelector('.hex-code');
                let existingControls = shadeContainer.querySelector('.controls');

                if (!existingShadeDisplay || !existingHexCode || !existingControls) {
                    shadeContainer.innerHTML = html;
                    existingShadeDisplay = shadeContainer.querySelector('.shade-display');
                    existingHexCode = shadeContainer.querySelector('.hex-code');
                    existingControls = shadeContainer.querySelector('.controls');
                }
                
                // Fade out hex code, update it, then fade in
                existingHexCode.style.opacity = '0';
                setTimeout(() => {
                    existingHexCode.textContent = newHex;
                    existingHexCode.style.opacity = '1';
                }, 150);
                if (existingShadeDisplay && newShade) {
                    existingShadeDisplay.setAttribute('data-shade', newShade);
                }
                if (existingControls) {
                    existingControls.style.removeProperty('background-color');
                    existingControls.style.removeProperty('color');
                }

                currentShade = newShade;
                updateShadeContext(newShade);

                // Reattach button listeners (in case controls were replaced)
                attachButtonListeners();
            } catch (error) {
                console.error('Error loading shade:', error);
            }
        }

        async function loadStats() {
            try {
                const response = await fetch('/stats');
                const html = await response.text();
                document.getElementById('stats-container').innerHTML = html;
                updateStoredColorsFromStats();
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        async function vote(choice) {
            const hexMatch = document.querySelector('.hex-code');
            if (!hexMatch) return;
            
            const shade = hexMatch.textContent.trim();
            
            const formData = new FormData();
            formData.append('shade', shade);
            formData.append('choice', choice);

            try {
                const response = await fetch('/vote', {
                    method: 'POST',
                    body: formData
                });
                const html = await response.text();
                document.getElementById('stats-container').innerHTML = html;
                updateStoredColorsFromStats();
                
                // Update favicon after voting
                updateFavicon();
                
                // Load next shade with smooth transition (no delay needed)
                loadNextShade();
            } catch (error) {
                console.error('Error voting:', error);
            }
        }

        function attachButtonListeners() {
            attachVoteHandler('.btn-yes', 'yes');
            attachVoteHandler('.btn-no', 'no');
            attachVoteHandler('.btn-skip', 'skip');
            attachHexCopy();
        }

        function attachVoteHandler(selector, voteType) {
            const button = document.querySelector(selector);
            if (!button) {
                return;
            }

            button.onclick = (e) => {
                const target = e.currentTarget;
                target.classList.add('animate-success');
                setTimeout(() => target.classList.remove('animate-success'), 400);
                vote(voteType);
            };
        }

        function attachHexCopy() {
            const hexEl = document.querySelector('.hex-code.copyable');
            if (!hexEl) {
                return;
            }

            hexEl.onclick = copyCurrentShadeHex;
            hexEl.onkeydown = (evt) => {
                if (evt.key === 'Enter' || evt.key === ' ' || evt.key === 'Spacebar') {
                    evt.preventDefault();
                    copyCurrentShadeHex({ currentTarget: hexEl });
                }
            };
        }

        async function copyCurrentShadeHex(event) {
            try {
                const hexEl = event?.currentTarget || document.querySelector('.hex-code.copyable');
                const shadeValue = hexEl ? hexEl.textContent.trim() : '';
                if (!shadeValue) {
                    showMessage('shade-message', 'No color to copy yet', 'error');
                    return;
                }

                const normalized = normalizeHex(shadeValue);
                if (!normalized || !HEX_COLOR_REGEX.test(normalized)) {
                    showMessage('shade-message', 'Invalid color value', 'error');
                    return;
                }

                const copied = await copyTextToClipboard(normalized);
                if (copied) {
                    showMessage('shade-message', `Color ${normalized} copied to clipboard!`, 'success', normalized);
                } else {
                    showMessage('shade-message', 'Unable to copy color to clipboard', 'error');
                }
            } catch (error) {
                console.error('Error copying current shade:', error);
                showMessage('shade-message', 'Unable to copy color to clipboard', 'error');
            }
        }

        function updateShadeContext(color) {
            const normalized = normalizeHex(color);
            const root = document.documentElement;
            const hasValidShade = normalized && HEX_COLOR_REGEX.test(normalized);

            if (hasValidShade) {
                root.style.setProperty('--page-background', normalized);
                const pageTextColor = getReadableTextColor(normalized);
                root.style.setProperty('--page-foreground', pageTextColor);
                root.style.setProperty('--shade-color', normalized);
            } else {
                root.style.removeProperty('--page-background');
                root.style.removeProperty('--page-foreground');
                root.style.removeProperty('--shade-color');
            }
        }

        async function saveBaseColor(event, overrideHex = null) {
            const saveBtn = event?.currentTarget || event?.target;
            if (saveBtn) {
                saveBtn.classList.add('animate-success');
                setTimeout(() => saveBtn.classList.remove('animate-success'), 400);
            }

            const colorToCopy = overrideHex || currentUserBaseColor || currentGlobalBaseColor;
            if (!colorToCopy) {
                showMessage('save-message', 'No color available yet. Make a selection first!', 'error');
                return;
            }

            const normalizedColor = ensureHexPrefix(colorToCopy);

            try {
                const copied = await copyTextToClipboard(normalizedColor);
                if (copied) {
                    showMessage('save-message', `Color ${normalizedColor} copied to clipboard!`, 'success', normalizedColor);
                } else {
                    showMessage('save-message', 'Unable to copy color to clipboard', 'error');
                }
            } catch (error) {
                console.error('Error copying base color:', error);
                showMessage('save-message', 'Unable to copy color to clipboard', 'error');
            }
        }

        async function loadBaseColor(event) {
            const baseInput = document.getElementById('base-color-input');
            const baseColor = baseInput ? baseInput.value.trim() : '';

            updateRestorePreview(baseColor);
            
            if (!baseColor) {
                setRestoreInlineMessage('Please enter a color hex code', 'error');
                if (baseInput) {
                    baseInput.focus();
                    baseInput.select();
                }
                return;
            }

            const loadBtn = event?.currentTarget || event?.target;
            if (loadBtn) {
                loadBtn.classList.add('animate-success');
                setTimeout(() => loadBtn.classList.remove('animate-success'), 400);
            }

            const normalizedInput = normalizeHex(baseColor);
            const isValidHex = normalizedInput && HEX_COLOR_REGEX.test(normalizedInput);
            const normalizedUser = normalizeHex(currentUserBaseColor);

            if (!isValidHex) {
                setRestoreInlineMessage('Enter a valid 6-digit hex color', 'error');
                showMessage('restore-message', 'Invalid color value', 'error');
                if (baseInput) {
                    baseInput.focus();
                    baseInput.select();
                }
                return;
            }

            if (normalizedUser && normalizedInput === normalizedUser) {
                closeRestoreModal();
                showMessage('restore-message', 'Already using this Anika Blue. Refreshing...', 'success');
                setTimeout(() => {
                    loadStats();
                    loadNextShade();
                    updateFavicon();
                }, 500);
                if (baseInput) {
                    baseInput.value = '';
                }
                return;
            }

            clearRestoreInlineMessage();
            closeRestoreModal();

            const formData = new FormData();
            formData.append('base_color', normalizedInput);

            try {
                const response = await fetch('/load-base-color', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (data.success) {
                    showMessage('restore-message', 'Session restored! Reloading...', 'success');
                    // Reload stats and shade after a brief delay
                    setTimeout(() => {
                        loadStats();
                        loadNextShade();
                        updateFavicon();
                        if (baseInput) {
                            baseInput.value = '';
                        }
                    }, 1000);
                } else {
                    showMessage('restore-message', data.error || 'Failed to load color', 'error');
                }
            } catch (error) {
                console.error('Error loading base color:', error);
                showMessage('restore-message', 'Error loading color', 'error');
            }
        }

        function openRestoreModal(event) {
            const trigger = event?.currentTarget || event?.target;
            if (trigger) {
                trigger.classList.add('animate-success');
                setTimeout(() => trigger.classList.remove('animate-success'), 400);
            }

            const modal = document.getElementById('restore-modal');
            if (!modal) return;
            modal.classList.add('visible');

            const input = document.getElementById('base-color-input');
            clearRestoreInlineMessage();
            if (input) {
                const defaultValue = currentUserBaseColor || currentGlobalBaseColor || '';
                input.value = defaultValue;
                updateRestorePreview(defaultValue);
                // Delay focus slightly to ensure visibility on mobile keyboards
                setTimeout(() => {
                    input.focus();
                    input.select();
                }, 50);
            }
        }

        function closeRestoreModal() {
            const modal = document.getElementById('restore-modal');
            if (!modal) return;
            modal.classList.remove('visible');
            clearRestoreInlineMessage();
            updateRestorePreview(currentUserBaseColor || currentGlobalBaseColor || '');
        }

        function updateStoredColorsFromStats() {
            const container = document.getElementById('stats-container');
            if (!container) {
                return;
            }

            const userEl = container.querySelector('[data-color-role="user"]');
            const globalEl = container.querySelector('[data-color-role="global"]');

            currentUserBaseColor = userEl ? userEl.textContent.trim() : null;
            currentGlobalBaseColor = globalEl ? globalEl.textContent.trim() : null;

            const copyTargets = container.querySelectorAll('.color-swatch.copyable');
            copyTargets.forEach((swatch) => {
                const role = swatch.dataset.copyRole;
                swatch.onclick = (evt) => {
                    evt.preventDefault();
                    const overrideColor = role === 'user' ? currentUserBaseColor : role === 'global' ? currentGlobalBaseColor : null;
                    saveBaseColor(evt, overrideColor);
                };
                swatch.onkeydown = (evt) => {
                    if (evt.key === 'Enter' || evt.key === ' ' || evt.key === 'Spacebar') {
                        evt.preventDefault();
                        const overrideColor = role === 'user' ? currentUserBaseColor : role === 'global' ? currentGlobalBaseColor : null;
                        saveBaseColor({ currentTarget: swatch }, overrideColor);
                    }
                };
            });

            const restoreModal = document.getElementById('restore-modal');
            if (!restoreModal || !restoreModal.classList.contains('visible')) {
                updateRestorePreview(currentUserBaseColor || currentGlobalBaseColor || '');
            }
        }

        function normalizeHex(hex) {
            if (!hex) {
                return null;
            }
            let value = hex.trim().toLowerCase();
            if (!value.startsWith('#')) {
                value = `#${value}`;
            }
            return value;
        }

        function ensureHexPrefix(hex) {
            if (!hex) {
                return hex;
            }
            return hex.trim().startsWith('#') ? hex.trim() : `#${hex.trim()}`;
        }

        async function copyTextToClipboard(text) {
            if (!text) {
                return false;
            }

            const value = String(text);

            if (navigator.clipboard && navigator.clipboard.writeText) {
                try {
                    await navigator.clipboard.writeText(value);
                    return true;
                } catch (clipboardError) {
                    if (clipboardError && clipboardError.name !== 'NotAllowedError') {
                        console.warn('navigator.clipboard.writeText failed, falling back', clipboardError);
                    }
                }
            }

            let textarea;
            try {
                textarea = document.createElement('textarea');
                textarea.value = value;
                textarea.setAttribute('readonly', '');
                textarea.style.position = 'fixed';
                textarea.style.top = '-1000px';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                textarea.setSelectionRange(0, value.length);
                const successful = document.execCommand('copy');
                return successful;
            } catch (fallbackError) {
                console.error('Fallback clipboard copy failed:', fallbackError);
                return false;
            } finally {
                if (textarea && textarea.parentNode) {
                    textarea.parentNode.removeChild(textarea);
                }
            }
        }

        function getReadableTextColor(hex) {
            if (!hex || !HEX_COLOR_REGEX.test(hex)) {
                return '#1f2933';
            }
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance > 0.6 ? '#1f2933' : '#fdfdfd';
        }

        function updateRestorePreview(rawValue) {
            const preview = document.getElementById('restore-color-preview');
            const input = document.getElementById('base-color-input');
            if (!preview) {
                return;
            }

            const normalized = normalizeHex(rawValue);
            const isValid = normalized && HEX_COLOR_REGEX.test(normalized);

            if (input) {
                input.classList.toggle('invalid', !isValid && rawValue.trim() !== '');
                input.classList.toggle('valid', !!isValid);
            }

            if (isValid) {
                preview.style.background = normalized;
                preview.style.backgroundColor = normalized;
                preview.style.borderColor = 'rgba(0, 0, 0, 0.1)';
                preview.title = normalized;
                preview.setAttribute('data-valid', 'true');
            } else {
                preview.style.background = '';
                preview.style.backgroundColor = '';
                preview.style.borderColor = rawValue.trim() ? '#f5b1b8' : '#e0e0e0';
                preview.removeAttribute('title');
                preview.setAttribute('data-valid', 'false');
            }

            const copyBtn = document.getElementById('restore-copy-btn');
            if (copyBtn) {
                copyBtn.disabled = !isValid;
            }
        }

        function setRestoreInlineMessage(message, type) {
            const messageEl = document.getElementById('restore-inline-message');
            if (!messageEl) return;
            messageEl.textContent = message;
            messageEl.classList.remove('error', 'success');
            if (type) {
                messageEl.classList.add(type);
            }
        }

        function clearRestoreInlineMessage() {
            setRestoreInlineMessage('', null);
        }

        async function copyRestoreColor(event) {
            const button = event?.currentTarget || event?.target;
            const input = document.getElementById('base-color-input');
            if (button && button.disabled) {
                return;
            }
            if (button) {
                button.classList.add('copy-feedback');
                setTimeout(() => button.classList.remove('copy-feedback'), 250);
            }

            if (!input) {
                showMessage('restore-message', 'No color to copy yet', 'error');
                return;
            }

            const normalized = normalizeHex(input.value);

            if (!normalized || !HEX_COLOR_REGEX.test(normalized)) {
                setRestoreInlineMessage('Enter a valid 6-digit hex color first', 'error');
                showMessage('restore-message', 'Invalid color value', 'error');
                if (input) {
                    input.focus();
                    input.select();
                }
                return;
            }

            try {
                await navigator.clipboard.writeText(normalized);
                showMessage('restore-message', `Color ${normalized} copied to clipboard!`, 'success', normalized);
            } catch (error) {
                console.error('Error copying restore color:', error);
                showMessage('restore-message', 'Unable to copy color', 'error');
            }
        }

        function updateFavicon() {
            // Force favicon refresh by adding a timestamp
            const link = document.querySelector("link[rel='icon']");
            if (link) {
                link.href = '/favicon.ico?' + new Date().getTime();
            }
        }

        function showMessage(elementId, message, type, highlightHex = null) {
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            if (highlightHex) {
                const normalizedHighlight = normalizeHex(highlightHex);
                const idx = message.indexOf(normalizedHighlight);
                if (normalizedHighlight && idx >= 0) {
                    const before = message.slice(0, idx);
                    const after = message.slice(idx + normalizedHighlight.length);

                    toast.append(document.createTextNode(before));

                    const chip = document.createElement('span');
                    chip.className = 'toast-color-chip';
                    chip.textContent = normalizedHighlight;
                    chip.style.background = normalizedHighlight;
                    chip.style.color = getReadableTextColor(normalizedHighlight);
                    toast.append(chip);

                    toast.append(document.createTextNode(after));
                } else {
                    toast.textContent = message;
                }
            } else {
                toast.textContent = message;
            }
            
            // Add to body
            document.body.appendChild(toast);
            
            // Remove after animation completes
            setTimeout(() => {
                toast.remove();
            }, 5000);
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            loadNextShade();
            loadStats();
            startLiveReload();

            const baseInput = document.getElementById('base-color-input');
            if (baseInput) {
                baseInput.addEventListener('input', (evt) => {
                    updateRestorePreview(evt.target.value);
                });
                updateRestorePreview(baseInput.value);
            }

            document.addEventListener('keydown', (evt) => {
                if (evt.key === 'Escape') {
                    closeRestoreModal();
                }
            });
        });
    </script>
</body>
</html>
